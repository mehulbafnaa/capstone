theorem_name,id,verified,inference_time_sec,error_type,generated_tactics,ground_truth
AffineSubspace.perpBisector_ne_bot,2,False,42.4,forbidden_keyword,"```lean
open AffineSubspace
open Set
open scoped RealInnerProductSpace
variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] [MetricSpace P]
variable [NormedAddTorsor V P]
variable [NormedAddTorsor V P]
variable {c c‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ : P}

theorem AffineSubspace.perpBisector_ne_bot : perpBisector p‚ÇÅ p‚ÇÇ ‚â† ‚ä• := by
  intro p‚ÇÇ.ne_bot.bind(Œª p, rfl)
  rw [InnerProductSpace.perpBisector]
  ...
```","theorem AffineSubspace.perpBisector_ne_bot : perpBisector p‚ÇÅ p‚ÇÇ ‚â† ‚ä• := by
  rw [‚Üê nonempty_iff_ne_bot]; exact perpBisector_nonempty"
CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.isIso_hom_app,3,False,31.64,forbidden_keyword,"```lean
@[simps]
def coconeAtFunctor (Y : D) :
    LeftExtension L F ‚•§ Cocone (CostructuredArrow.proj L Y ‚ãô F) where
  obj E := E.coconeAt Y
  map {E E'} œÜ := CoconeMorphism.mk (œÜ.right.app Y) (fun G => by
    dsimp
    rw [‚Üê StructuredArrow.w œÜ]
    simp)

theorem CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.isIso_hom_app 
    {X : C} (h : E.IsPointwiseLeftKanExtensionAt (L.obj X)) [L.Full] [L.Faithful] :
    IsIso (E.hom.app X) := by
  rw [IsPointwiseLeftKanExtensionAt.hasPointwiseLeftKanExtensionAt h]
  exact (E.hom.app X).is_iso
```","theorem CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtensionAt.isIso_hom_app 
    {X : C} (h : E.IsPointwiseLeftKanExtensionAt (L.obj X)) [L.Full] [L.Faithful] :
    IsIso (E.hom.app X) := by
  simpa using h.isIso_Œπ_app_of_isTerminal _ CostructuredArrow.mkIdTerminal"
PrincipalSeg.topLTTop,4,False,31.55,forbidden_keyword,"```lean
import Mathlib.Logic.Equiv.Set
import Mathlib.Order.RelIso.Set
import Mathlib.Order.WellFounded
import Mathlib.Order.InitialSeg

open PrincipalSeg
variable {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop}
  {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop}
open Function

theorem PrincipalSeg.topLTTop {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} [IsWellOrder Œ≥ t] (f : PrincipalSeg r s) (g : PrincipalSeg s t) (h : PrincipalSeg r t) : t h.top g.top := by
  intro e; lia; intro e; lia;
  rw [Subsingleton.elim f (PrincipalSeg.equivLT e g)]; rfl
```","theorem PrincipalSeg.topLTTop {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop} [IsWellOrder Œ≥ t]
    (f : PrincipalSeg r s) (g : PrincipalSeg s t) (h : PrincipalSeg r t) : t h.top g.top := by
  rw [Subsingleton.elim h (f.trans g)]
  apply PrincipalSeg.lt_top"
CategoryTheory.ChosenFiniteProducts.lift_fst,5,False,34.29,forbidden_keyword,"```lean
import Mathlib.Logic.Equiv.Set
import Mathlib.Order.RelIso.Set
import Mathlib.Order.WellFounded
import Mathlib.Order.InitialSeg

open InitialSeg
variable {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop}
  {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop}
open Function

theorem InitialSeg.eq [IsWellOrder Œ≤ s] (f g : r ‚âºi s) (a) : f a = g a := by
  intro h. rewrite [Subsingleton.elim f g] using h. lia

theorem InitialSeg.eq [IsWellOrder Œ≤ s] (f g : r ‚âºi s) (a) : f a = g a := by
  intro h. rewrite [Subsingleton.elim g h] using h. lia

rw [Subsingleton.elim f (PrincipalSeg.equivLT e g)]; rfl
```","theorem CategoryTheory.ChosenFiniteProducts.lift_fst {T X Y : C} (f : T ‚ü∂ X) (g : T ‚ü∂ Y) : lift f g ‚â´ fst _ _ = f := by
  simp [lift, fst]"
AffineSubspace.mem_perpBisector_iff_dist_eq',6,False,34.71,forbidden_keyword,"```lean
open AffineSubspace
open Set
open scoped RealInnerProductSpace
variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] [MetricSpace P]
variable [NormedAddTorsor V P]
variable [NormedAddTorsor V P]
variable {c c‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ : P}

theorem AffineSubspace.mem_perpBisector_iff_dist_eq' : c ‚àà perpBisector p‚ÇÅ p‚ÇÇ ‚Üî dist p‚ÇÅ c = dist p‚ÇÇ c := by
  (mono) ‚ü®c, p‚ÇÅ p‚ÇÇ‚ü© ‚ü®Œª x, dist x p‚ÇÅ p‚ÇÇ‚ü©
  (mono) ‚ü®p‚ÇÅ c, p‚ÇÇ c‚ü© ‚ü®Œª x, dist x p‚ÇÅ p‚ÇÇ‚ü©
  (using Subsingleton.elim, normed_add_comm_group_add_torsor_iff_dist_eq, normed_add_torsor_add_torsor_iff_dist_eq)
```","theorem AffineSubspace.mem_perpBisector_iff_dist_eq' : c ‚àà perpBisector p‚ÇÅ p‚ÇÇ ‚Üî dist p‚ÇÅ c = dist p‚ÇÇ c := by
  simp only [mem_perpBisector_iff_dist_eq, dist_comm]"
AffineSubspace.right_mem_perpBisector,7,False,33.77,forbidden_keyword,"```lean
open AffineSubspace
open Set
open scoped RealInnerProductSpace
variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] [MetricSpace P]
variable [NormedAddTorsor V P]
variable [NormedAddTorsor V P]
variable {c c‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ : P}

theorem AffineSubspace.right_mem_perpBisector : p‚ÇÇ ‚àà perpBisector p‚ÇÅ p‚ÇÇ ‚Üî p‚ÇÅ = p‚ÇÇ := by
  (using Subsingleton.elim p‚ÇÅ p‚ÇÇ (1))
  (using Subsingleton.elim p‚ÇÇ p‚ÇÅ (2))
  (using equiv_intro (InnerProductSpace.perpBisector ‚Ñù V) (InnerProductSpace.perpBisector ‚Ñù V))
```","theorem AffineSubspace.right_mem_perpBisector : p‚ÇÇ ‚àà perpBisector p‚ÇÅ p‚ÇÇ ‚Üî p‚ÇÅ = p‚ÇÇ := by
  simpa [mem_perpBisector_iff_inner_eq_inner] using eq_comm"
CategoryTheory.ChosenFiniteProducts.lift_snd,8,False,2.77,forbidden_keyword,"```lean
import Mathlib.Logic.Equiv.Set
import Mathlib.Order.RelIso.Set
import Mathlib.Order.WellFounded
import Mathlib.Order.InitialSeg

open InitialSeg
variable {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop}
  {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop}
open Function

theorem InitialSeg.eq [IsWellOrder Œ≤ s] (f g : r ‚âºi s) (a) : f a = g a := by
  intro h. rewrite [Subsingleton.elim f g] using h. lia

theorem InitialSeg.eq [IsWellOrder Œ≤ s] (f g : r ‚âºi s) (a) : f a = g a := by
  intro h. rewrite [Subsingleton.elim g] using h. lia

rw [Subsingleton.elim f (PrincipalSeg.equivLT e g)]; rfl
```","theorem CategoryTheory.ChosenFiniteProducts.lift_snd {T X Y : C} (f : T ‚ü∂ X) (g : T ‚ü∂ Y) : lift f g ‚â´ snd _ _ = g := by
  simp [lift, snd]"
CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ_id,9,False,30.46,forbidden_keyword,"```lean
open CategoryTheory
open OverPresheafAux
open YonedaCollection
open Category Opposite

variable {C : Type u} [Category.{v} C] {A : C·µí·µñ ‚•§ Type v}
variable {F : (CostructuredArrow yoneda A)·µí·µñ ‚•§ Type v} {X : C}

theorem CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ_id : YonedaCollection.map‚ÇÅ (ùüô F) (X := X) = id := by
  rw YonedaCollection.map1_id [of ùüô F X]
  exact CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ (ùüô F) (X := X)
```","theorem CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÅ_id : YonedaCollection.map‚ÇÅ (ùüô F) (X := X) = id := by
  aesop_cat"
CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.hom_ext,10,False,34.44,forbidden_keyword,"```lean
import Mathlib.Logic.Equiv.Set
import Mathlib.Order.RelIso.Set
import Mathlib.Order.WellFounded
import Mathlib.Order.InitialSeg

open InitialSeg
variable {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop}
  {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop}
open Function

theorem InitialSeg.eq [IsWellOrder Œ≤ s] (f g : r ‚âºi s) (a) : f a = g a := by
  rw [Subsingleton.elim f g]

theorem InitialSeg.eq [IsWellOrder Œ≤ s] (f g : r ‚âºi s) (a) : f a = g a := by
  rw [Subsingleton.elim f g]
  rw [InitialSeg.initial_segment]
  exact rfl

theorem PrincipalSeg.top_eq [IsWellOrder Œ≥ t] (e : r ‚âÉr s) (f : r ‚â∫i t) (g : s ‚â∫i t) : f.top = g.top := by
  rw [Subsingleton.elim f (PrincipalSeg.equivLT e g)]; rfl

@[simps]
def coconeAtFunctor (Y : D) :
    LeftExtension L F ‚•§ Cocone (CostructuredArrow.proj L Y ‚ãô F) where
  obj E := E.coconeAt Y
  map {E E'} œÜ := CoconeMorphism.mk (œÜ.right.app Y) (fun G => by
    dsimp
    rw [‚Üê StructuredArrow.w œÜ]
    simp)

variable {E} in
lemma IsPointwiseLeftKanExtensionAt.hasPointwiseLeftKanExtensionAt
    {Y : D} (h : E.IsPointwiseLeftKanExtensionAt Y) :
    HasPointwiseLeftKanExtensionAt L F Y := ‚ü®_, h‚ü©

variable {E E'}
variable (h : E.IsPointwiseLeftKanExtension)
include h

theorem CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.hom_ext
    {G : LeftExtension L F} {f‚ÇÅ f‚ÇÇ : E ‚ü∂ G} : f‚ÇÅ = f‚ÇÇ := by
  rw [‚Üê IsPointwiseLeftKanExtensionAt.hasPointwiseLeftKanExtensionAt h]
  exact (f‚ÇÅ ‚â° f‚ÇÇ).
```","theorem CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.hom_ext 
    {G : LeftExtension L F} {f‚ÇÅ f‚ÇÇ : E ‚ü∂ G} : f‚ÇÅ = f‚ÇÇ := by
  ext Y
  apply (h Y).hom_ext
  intro X
  have eq‚ÇÅ := congr_app (StructuredArrow.w f‚ÇÅ) X.left
  have eq‚ÇÇ := congr_app (StructuredArrow.w f‚ÇÇ) X.left
  dsimp at eq‚ÇÅ eq‚ÇÇ ‚ä¢
  simp only [assoc, NatTrans.naturality]
  rw [reassoc_of% eq‚ÇÅ, reassoc_of% eq‚ÇÇ]"
CategoryTheory.OverPresheafAux.counitForward_val_fst,11,False,31.92,forbidden_keyword,"```lean
import Mathlib.Logic.Equiv.Set
import Mathlib.Order.RelIso.Set
import Mathlib.Order.WellFounded
import Mathlib.Order.InitialSeg

open InitialSeg
variable {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop}
open Function

theorem InitialSeg.eq [IsWellOrder Œ≤ s] (f g : r ‚âºi s) (a) : f a = g a := by
  - exact InitialSeg.eq [IsWellOrder Œ≤ s] (f g) (a)
  - rw [Subsingleton.elim f g]

theorem InitialSeg.eq [IsWellOrder Œ≤ s] (f g : r ‚âºi s) (a) : f a = g a := by
  rw [Subsingleton.elim f g]
  exact InitialSeg.eq [IsWellOrder Œ≤ s] (f g) (a)
```","theorem CategoryTheory.OverPresheafAux.counitForward_val_fst (s : CostructuredArrow yoneda A) (x : F.obj (op s)) :
    (counitForward F s x).val.fst = s.hom := by
  simp"
CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isIso_hom_app,12,False,32.45,forbidden_keyword,"```lean
intros {Œ± Œ≤ Œ≥ r s t : C} {f g : E.IsPointwiseRightKanExtensionAt (L.obj X)} {a : E.obj X}
rw [Functor.RightExtension.isPointwiseRightKanExtensionAt_is_hom_app]
    (L.Full ‚àß L.Faithful)
    (L.obj X Hom.app X a)
    (L.obj X Hom.app X g)
    (L.obj X Hom.app X f)
    (r ‚âÉ r s)
    (s ‚â∫ i t)
    (f.top = g.top)
using IsWellOrder.subsingleton_elim
```","theorem CategoryTheory.Functor.RightExtension.IsPointwiseRightKanExtensionAt.isIso_hom_app 
    {X : C} (h : E.IsPointwiseRightKanExtensionAt (L.obj X)) [L.Full] [L.Faithful] :
    IsIso (E.hom.app X) := by
  simpa using h.isIso_œÄ_app_of_isInitial _ StructuredArrow.mkIdInitial"
AlgebraicGeometry.topologically_iso_le,13,False,35.92,forbidden_keyword,"```lean
import Mathlib.AlgebraicGeometry.Morphisms.Basic
import Mathlib.RingTheory.RingHomProperties
import Mathlib.AlgebraicGeometry.Morphisms.Constructors

open AlgebraicGeometry
open TopologicalSpace CategoryTheory CategoryTheory.Limits Opposite

variable (P : ‚àÄ {Œ± Œ≤ : Type u} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (_ : Œ± ‚Üí Œ≤), Prop)

theorem AlgebraicGeometry.topologically_iso_le 
    (hP : ‚àÄ {Œ± Œ≤ : Type u} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (f : Œ± ‚âÉ‚Çú Œ≤), P f) :
    MorphismProperty.isomorphisms Scheme ‚â§ (topologically P) := by
  - exact (fun {Œ± Œ≤ : Type u} => P f Œ± ‚âÉ‚Çú Œ≤)
  - exact (fun {Œ± Œ≤ : Type u} => P f Œ± ‚âÉ‚Çú Œ≤)
  rw [Subsingleton.elim f]
```","theorem AlgebraicGeometry.topologically_iso_le 
    (hP : ‚àÄ {Œ± Œ≤ : Type u} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] (f : Œ± ‚âÉ‚Çú Œ≤), P f) :
    MorphismProperty.isomorphisms Scheme ‚â§ (topologically P) := by
  intro X Y e (he : IsIso e)
  have : IsIso e := he
  exact hP (TopCat.homeoOfIso (asIso e.val.base))"
CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ_id,14,False,33.84,forbidden_keyword,"```lean
import Mathlib.Logic.Equiv.Set
import Mathlib.Order.RelIso.Set
import Mathlib.Order.WellFounded
import Mathlib.Order.InitialSeg

open InitialSeg
variable {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop}
  {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop}
open Function

theorem CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ_id : YonedaCollection.map‚ÇÇ F (ùüô X) = id := by
  intro h‚ÇÅ h‚ÇÇ; exact (YonedaCollection.map‚ÇÇ F (ùüô X) h‚ÇÅ h‚ÇÇ)
```","theorem CategoryTheory.OverPresheafAux.YonedaCollection.map‚ÇÇ_id : YonedaCollection.map‚ÇÇ F (ùüô X) = id := by
  ext; all_goals simp"
AffineSubspace.midpoint_mem_perpBisector,15,False,35.49,forbidden_keyword,"```lean
import Mathlib.Analysis.InnerProductSpace.Orthogonal
import Mathlib.Analysis.Normed.Group.AddTorsor
import Mathlib.Geometry.Euclidean.PerpBisector

open AffineSubspace
open Set
open scoped RealInnerProductSpace
variable {V P : Type*} [NormedAddCommGroup V] [InnerProductSpace ‚Ñù V] [MetricSpace P]
variable [NormedAddTorsor V P]
variable [NormedAddTorsor V P]
variable {c c‚ÇÅ c‚ÇÇ p‚ÇÅ p‚ÇÇ : P}


theorem AffineSubspace.midpoint_mem_perpBisector (p‚ÇÅ p‚ÇÇ : P) :
    midpoint ‚Ñù p‚ÇÅ p‚ÇÇ ‚àà perpBisector p‚ÇÅ p‚ÇÇ := by
  apply (fun x -> midpoint ‚Ñù x p‚ÇÅ p‚ÇÇ)
  using AffineSubspace.midpoint
  using AddTorsor.is_zero
  using Normed.AddTorsor.is_zero
  using MetricSpace.is_metrizable
```","theorem AffineSubspace.midpoint_mem_perpBisector (p‚ÇÅ p‚ÇÇ : P) :
    midpoint ‚Ñù p‚ÇÅ p‚ÇÇ ‚àà perpBisector p‚ÇÅ p‚ÇÇ := by
  simp [mem_perpBisector_iff_inner_eq_zero]"
CategoryTheory.OverPresheafAux.app_unitForward,16,False,31.82,forbidden_keyword,"```lean
import Mathlib.Logic.Equiv.Set
import Mathlib.Order.RelIso.Set
import Mathlib.Order.WellFounded
import Mathlib.Order.InitialSeg

open InitialSeg
variable {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop}
  {t : Œ≥ ‚Üí Œ≥ ‚Üí Prop}
open Function

theorem InitialSeg.eq [IsWellOrder Œ≤ s] (f g : r ‚âºi s) (a) : f a = g a := by
  intro h.le_iff.rewrite [Subsingleton.elim f g]
  rw [Subsingleton.elim h]
  exact h.right

theorem InitialSeg.eq [IsWellOrder Œ≤ s] (f g : r ‚âºi s) (a) : f a = g a := by
  intro h.le_iff.rewrite [Subsingleton.elim h]
  rw [Subsingleton.elim g]
  exact g.left
```","theorem CategoryTheory.OverPresheafAux.app_unitForward {F : C·µí·µñ ‚•§ Type v} (Œ∑ : F ‚ü∂ A) (X : C·µí·µñ)
    (p : YonedaCollection (restrictedYonedaObj Œ∑) X.unop) :
    Œ∑.app X (unitForward Œ∑ X.unop p) = p.yonedaEquivFst := by
  simpa [unitForward] using p.snd.app_val"
